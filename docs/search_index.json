[["booklet.html", "jmvScaffold: R functions to develop jamovi modules Chapter 1 Introduction 1.1 Preface 1.2 Getting Started 1.3 Create a module 1.4 Defining the analysis 1.5 jamovi analysis", " jmvScaffold: R functions to develop jamovi modules Marcello Gallucci 2023 Chapter 1 Introduction 1.1 Preface Draft version, mistakes may be around Here you can find a how-to to build a jamovi package using the R package jmvScaffold, which provides several functions and R6 classes to ease the development of jamovi modules. Much of the jamovi module development information can be found in the jamovi developer’s hub. Reference and detailed functions description of the package can be found in jmvScaffold reference page. This documentation assumes that the reader is familiar with the basic of jamovi module development, but one may get away without that, and be able to develop a jamovi module only reading these pages. We should note that developing a jamovi module does not require any of this material. This material, furthermore, will not make your coding easier than just using jamovi functions as described in jamovi developer’s hub. However, when your module starts to get a bit complicated, offering several analyses and sub-modules, or when you want your module to do more sophisticate actions, or more refined style, this material may come handy. A final word to end the preface: Here we assume that we want to build a jamovi module, store it to (github)[https://github.com], and then publish it in the jamovi library. If you do not have the second or the third aim (you may want to build a module only for yourself), you can skip the parts related with them. 1.2 Getting Started First, you need to get ready for developing a module, so you want to consult jamovi developer’s hub getting started section. In a nutshell, you need: To install jamovi To install jmvtools R package, provided by the jamovi core developing group. install.packages(&#39;jmvtools&#39;, repos=c(&#39;https://repo.jamovi.org&#39;, &#39;https://cran.r-project.org&#39;)) To install jmvScaffold R package (check out if you need some dependency) devtools::install_github(&quot;mcfanda/jmvScaffold&quot;) We will see that your module will not need to install jmvScaffold to work, you just need it to program. 1.3 Create a module A module in jamovi is a R package that works also in jamovi. As such, it needs to have all the charateristics of a R package, plus the additional information and coding required to interface the R package to jamovi. Thus, to obtain a working module we need to make steps both for the R package and for the jamovi interface. We now create a new module, named COOLj. At the end of this material, the COOLj module will look like !TODO SAY what it does! this. First, we create its folder (so be sure you are in a parent folder) and the folders structure with jmvtool jmvtools::create(&#39;COOLj&#39;) This should produce, in the COOLj folder, this structure. If you use (RStudio)[https://posit.co/], its a good idea to create a project in the COOLj folder, because working with RStudio projects make our lives much easier. We now need to fill the DESCRIPTION file as for any R package. Here an example Package: COOLj Type: Package Title: Simple example of jmvScaffold Version: 0.0.1 Author: mcfanda Maintainer: Mcfanda &lt;yourself@somewhere.net&gt; Description: This is an example of jmvScaffold License: GPL Encoding: UTF-8 LazyData: true Imports: jmvcore (&gt;= 0.8.5), R6 This describe your package in R. Now we need to define a description for jamovi, filling the file ./jamovi/0000.yaml title: Simple example of jmvScaffold name: COOLj version: 0.0.1 jms: &#39;1.0&#39; authors: - Mcfanda maintainer: mcfanda &lt;yourself@somewhere.net&gt; date: &#39;2023-1-1&#39; type: R description: &gt;- This is an example of jmvScaffold analyses: [] usesNative: true minApp: 1.0.8 We will get back to this file later on. 1.4 Defining the analysis A module can do several things, but at least it should execute one analysis. By analysis I mean a set of stats that would produce some results, such as t-test, a correlation, a machine learning classification algorithm. In this example we want to develop a module that deal with linear models. We start simply, and aim at producing a linear regression. We make it more complex later on. By default, jamovi comes with a nice command Regression-&gt;Linear Regression, or with the GAMLj module for regressions and many other linear models. Here we set this aim for demonstrative purposes. 1.5 jamovi analysis We want to call this analysis myRegression. so, we create a file named myRegression in the ./jamovi/ folder. jmvtools::addAnalysis(name=&#39;myRegression&#39;, title=&#39;Regression analysis&#39;) The option name decides the name of the R function that will be produced, and the option title decides how the function will be labelled in the jamovi menu (it can be changed later on if needed). Running the command produces several files. In the ./jamovi/ folder we have In them, the jamovi input and output features are defined. In __*.a.yaml__ the input options are defined (see API here jamovi hub) In __*.u.yaml__ the input layout is of the user interface is defined (see API here jamovi hub) In __*.r.yaml__ the output results tables are defined (see API here jamovi hub) We should fill them all. "],["interface.html", "Chapter 2 Interface 2.1 Options (.a.yaml) 2.2 Layout (.u.yaml)", " Chapter 2 Interface library(mcdocs) knitr::knit_engines$get(&quot;yaml&quot;) 2.1 Options (.a.yaml) Every control the user sees in the input panel of our analysis must be defined in the *.a.yaml file. An example is this, generated by the jamovi compiler default settings: name: myRegression title: Regression analysis menuGroup: COOLj version: &#39;1.0.0&#39; jas: &#39;1.2&#39; options: - name: data type: Data - name: dep title: Dependent Variable type: Variable - name: group title: Grouping Variable type: Variable - name: alt title: Alternative hypothesis type: List options: - title: Not equal name: notequal - title: One greater name: onegreater - title: Two greater name: twogreater default: notequal Each option should have a name and a type. Depending to the type, other properties can be defined. For our purposes, we need a Variable type to input the dependent variable and a Variables type to input independent variables, plus the Data type that will pass the spreadsheet data to the R package. name: myRegression title: Regression analysis menuGroup: COOLj version: &#39;1.0.0&#39; jas: &#39;1.2&#39; - name: data type: Data - name: dep title: Dependent Variable type: Variable permitted: - numeric - name: covs title: Covariates type: Variables suggested: - continuous - ordinal permitted: - numeric First, notice the menuGroup property. That says in which menu the analysis will appear in jamovi. Because the COOLj menu does not exist, the compiler will create one. Later we see how to put your module under pre-existing menus. Now, the dep option will contain the dependent variable, and the property permitted allows the user to input only numerical variables (see appendix A) for more details about variables types in jamovi). The covs option will contain the numeric independent variables, and the GUI will signal with little icons that the field expects continuous or ordinal variable, ruled by the property suggested. The complete list of options and their properties can be found at the jamovi hub At this point we compile it and see what happens. jmvtools::install() If everything went as expected, you should see the COOLj module in jamovi. You do not need to restart jamovi, the compiler would restart the internal engine automatically and you should see the new module. 2.2 Layout (.u.yaml) We need to decide how to lay out the options in the GUI. The layout of the GUI is made of a series of LayoutBox, empty containers that host the controls (the options) as their children. Our options are all numeric, so require an text input control named TextBox. The layout is basically an HTML page, so one can think of a LayoutBox as a &lt;div&gt;, containing all the controls &lt;input type=\"text\"&gt;,&lt;input type=\"checkbox\"&gt; etc. For now, we set it like this: --- title: Regression analysis name: powerReg jus: &#39;3.0&#39; stage: 0 compilerMode: tame children: - type: LayoutBox margin: large children: - type: TextBox name: es format: number - type: TextBox name: alpha format: number - type: TextBox name: power format: number ... Notice that we set compiler: to tame, because it tells the jamovi compiler not to override our layout. Now we have a scaffold to start programming the stats, so we can now use jmvScaffold. "],["results.html", "Chapter 3 Results 3.1 Preparing the results 3.2 Defining the result tables (.r.yaml) 3.3 R code for jamovi 3.4 Initialize a table 3.5 Filling a table 3.6 Passing data to SmartTables 3.7 Automatic filling of tables.", " Chapter 3 Results library(mcdocs) knitr::knit_engines$get(&quot;yaml&quot;) 3.1 Preparing the results Results in jamovi are organized in tables (and some other widget type). Tables are R6 classes with many different properties and options, which allow the programmer to fine-tune the look and feel of the results in almost every details. The full information about jamovi results widgets can be found at the jamovi hub. jmvScaffold provides a R6 class, named SmartTables, which interface the programmer with the jamovi results API. With that, you can do a lot of things without touching the jamovi results classes. Before that, however, we need to declare what our tables should be. In our little project, we need at least one table for the regression results. It is a good idea, I suggest, to see how the R table would look like. In R, we would obtain the results of a linear regression with lm() command from stats:: package, so we basically need to run this # data will arrive from jamovi, here we fake one dataset data &lt;- data.frame(y=rnorm(50),x=rnorm(50)) model &lt;- stats::lm(y~x,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.2086023 0.1237982 -1.6850196 0.09847669 ## x -0.1081020 0.1201874 -0.8994459 0.37290547 Because we do not want spaces in the table heads, we can rename the table names to obtain a solid table, as a dataset. # data will arrive from jamovi, here we fake one dataset coeffs &lt;- as.data.frame(coeffs) names(coeffs)&lt;-c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs ## coef se t p ## (Intercept) -0.2086023 0.1237982 -1.6850196 0.09847669 ## x -0.1081020 0.1201874 -0.8994459 0.37290547 now that we know how our table will look like we should get into the R programming. As a side note, I would suggest to always use R commands prefixed with their package, such as stats::lm rather than lm. This is required if you want to publish your R module in CRAN, and it makes your code much more readable. It is like calling functions with their name and surname, and we want to be polite with our functions. 3.2 Defining the result tables (.r.yaml) All results tables (and other widgets) are defined in the .r.yaml. Here we need a table that will represent the R table we have seen before. So we need the following code. --- name: myRegression title: Regression analysis jrs: &#39;1.1&#39; - name: coefficients title: Parameter Estimates (Coefficients) type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: coef title: &quot;Estimate&quot; type: number - name: se title: SE type: number - name: t title: &quot;t&quot; type: number format: zto - name: p title: &quot;p&quot; type: number format: zto,pvalue --- So, a widget of type Table, with columns defined by a name, a title and a format. Details of all widgets definitions can be found in the jamovi hub Compiling the module after defining the table in the .r.R file produces the table in the output (still empty) 3.3 R code for jamovi When we first compiled our module, jamovi compiler produced to two R files and put them in the ./R folder. The .h.R file can be ignored, the jamovi compiler produces it every time we install the module. The important file is the .b.R file, where all the action takes place. The .b.R file contains a R6 class named [analysisname]Class, in our case myRegressionClass. The class contains (at least) two private functions, the .init() function and the .run() function. Those are the functions that we need to customize. Before we dive into it, let’s spend two words about how jamovi process works. When the user opens the analysis, or whenever the GUI is update, jamovi runs your R module in the .b.R file. It calls the .init() function first and then the .run() function. Actually, the .init() function can be absent, but my suggestion is to define it for all analyses, because in the .init() function the tables are formated and prepared to be filled. They are filled in the .run() function. A working .b.R file, that does not do anything, is the following: myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .init = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) }, .run = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) } ) ) Here is where jmvScaffold comes handy. First, we want to be sure to have installed the jmvScaffold classes. To do that, in R we simply run this code (recall from 1.2 that we installed the jmvScaffold R package) jmvScaffold::copy_files() which copies in the present module ./R folder the necessary files. 3.4 Initialize a table Table objects are passed to the R package with the property self$results. This property is a named list, so we can refer to our table as self$table$coefficients. In the .init() function, we should create a SmartTable object initialized with the table it is going to handle. We simply write this code. myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .regtab=NULL, .init = function() { private$.regtab&lt;-SmartTable$new(self$results$coefficients) private$.regtab$initTable() }, .run = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) } ) ) which define a SmartTable, it intialize it and save it in a private variable .regtab for later use. By now, the intialization does not do anything, but creating the SmartTable object. 3.5 Filling a table We can now fill it in the .run() function. First, recall the options we defined in the .a.yalm file. The will all be available in R as a named list named self$options. So we can get them to define our regression models. We should get the option dep to know which is our dependent variable, then we call the option covs. In the .run() function, we can write. .run = function() { dep &lt;- self$options$dep covs &lt;- self$options$covs } dep is a string containing the variable name, whereas covs is a list, so we need to manipulated it to make it a formula to pass it to lm(). This can be done easely with jmvcore R package, which provides very useful functions (see rext_url(“jmvcore Package”,“https://cran.r-project.org/web/packages/jmvcore/index.html”)` for details. .run = function() { dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) } Notice the function is.something(). It is provided by jmvScaffold and it is useful to evaluate options, because options can be of very different classes, and we just want to know if they are set or not. is.something does that. A this point, we should compute the regression and build a R table to pass to our SmartTable object defined before. myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .regtab=NULL, .init = function() { private$.regtab&lt;-SmartTable$new(self$results$coefficients) private$.regtab$initTable() }, .run = function() { data &lt;- self$data dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) model &lt;- stats::lm(formula,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) private$.regtab$runSource &lt;- coeffs private$.regtab$runTable() } ) ) What matters here is that we have passed out result table coeffs to the SmartTable with the command private$.regtab$runSource &lt;- coeffs and tell the table to update with the command private$.regtab$runTable(). We can now install the module in jamovi and check if it works. It does work! However, the Variable column is empty. We want to fill it with the names of the covariates. So we simply add the code necessary to add a column to our R data.frame. .run = function() { data &lt;- self$data dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) model &lt;- stats::lm(formula,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) private$.regtab$runSource &lt;- coeffs private$.regtab$runTable() } We have now a decent table with the results. It goes without saying that one can add any number of covariates, and the table will update automatically. 3.6 Passing data to SmartTables The SmartTable object accept tables in several different formats, so one can use different strategies depending on their need. passing a data.frame to $runSource passing a function that returns a data.frame to $runSource passing a list of named list, where each list represents a row and the names are the name of the columns passing a function that returns a list of named list initializing the SmartTable with an R6 object (see later on for a detailed explanation) We can try these strategies (but the last) with some simple code, passing some number to our coefficients table .run = function() { ## passing a function fun&lt;-function() { var=c(&quot;a,&quot;,&quot;b&quot;,&quot;c&quot;) coef=1:3 se=4:6 t=7:9 p=10:12 return(data.frame(var,estimate,se,t,p)) } private$.regtab$runSource &lt;- fun private$.regtab$runTable() } .run = function() { ## passing a list of named list alist&lt;-list( list(var=&quot;a&quot;,coef=1,se=4,t=7,p=10), list(var=&quot;b&quot;,coef=2,se=5,t=8,p=11), list(var=&quot;b&quot;,coef=3,se=6,t=9,p=12) ) private$.regtab$runSource &lt;- alist private$.regtab$runTable() } The possibility to pass results to a SmartTable in different ways gives the programmer flexibility to populate tables from different sources. Nonetheless, when the module gets very complex, even this flexibility cannot be enough. When things get complex, the last method may result the best: associating the tables to a R6 class that it is automatically called by the tables themselves. Sound complex but it is not. 3.7 Automatic filling of tables. When a SmartTable is initialized, it can be associated with an R6 class that provides the functions to run the table. When the table is run with the $runTable() function, it calls the R6 and inquires if the class has a function called run_[tablename]. If it is there, it execute the function and the table is filled with the return of the function. library(mcdocs) knitr::knit_engines$get(&quot;yaml&quot;) "],["final-words.html", "Chapter 4 Final Words", " Chapter 4 Final Words We have finished a nice book. "],["references.html", "References", " References Some references knitr::knit_engines$get(&quot;yaml&quot;) "],["appendixa.html", "A Appendix A", " A Appendix A jamovi classifies data variables in three classes: Nominal : categorical factor, it is passed to the R engine as a factor. Its behavior in jamovi interface depends on the Data Type property. We have Data Type: integer it can be inserted in input field that permit numerical variable and nominal variables Data Type: text it can be inserted in input field that permit nominal variables Data Type: decimal it does not exist. Setting Data Type to decimal makes the variable a continuous type Continuous : numerical variable, it is passed to the R engine as a number. It can be input in the variable field that permit numerical variable. The data type property behaves like this: Data Type: integer it rounds the values to the closer integer Data Type: decimal allows for floating points Data Type: text it does not exist, setting Data Type to text transforms the variable into a nominal variable Ordinal : numerical variable, it is passed to the R engine as a ordered factor. It can be input in the variable field that permit numerical and ordinal variables variable. The data type property behaves like this: Data Type: integer it can be inserted in input field that permit numerical variable and nominal variables Data Type: text it can be inserted in input field that permit nominal variables Data Type: decimal it does not exist. Setting Data Type to decimal makes the variable a continuous type ID : something cool which I do not know about. "]]
