[["booklet.html", "jmvScaffold: R functions to develop jamovi modules Chapter 1 Introduction 1.1 Preface 1.2 Getting Started 1.3 Create a module 1.4 Defining the analysis 1.5 jamovi analysis", " jmvScaffold: R functions to develop jamovi modules Marcello Gallucci 2023 Chapter 1 Introduction 1.1 Preface Draft version, mistakes may be around Here you can find a how-to to build a jamovi package using the R package jmvScaffold, which provides several functions and R6 classes to ease the development of jamovi modules. Much of the jamovi module development information can be found in the jamovi developer’s hub. Reference and detailed functions description of the package can be found in jmvScaffold reference page. We should note that developing a jamovi module does not require any of this material. This material, furthermore, will not make your coding easier than just using jamovi functions as described in jamovi developer’s hub. However, when your module starts to get a bit complicated, offering several analyses and sub-modules, or when you want your module to do more sophisticate actions, or more refined style, this material may come handy. This documentation assumes that the reader is familiar with the basic of jamovi module development, but one may get away without that, and be able to develop a jamovi module only reading these pages. To program a jamovi module, you want to have a basic knowledge of R6 classes. You do not need much, as it is very easy to work with them. R6 classes brings object oriented programming to R. R6 objects are basically functions that know themselves. A final word to end the preface: Here we assume that we want to build a jamovi module, store it to (github)[https://github.com], and then publish it in the jamovi library. If you do not have the second or the third aim (you may want to build a module only for yourself), you can skip the parts related with them. 1.2 Getting Started First, you need to get ready for developing a module, so you want to consult jamovi developer’s hub getting started section. In a nutshell, you need: To install jamovi To install jmvtools R package, provided by the jamovi core developing group. install.packages(&#39;jmvtools&#39;, repos=c(&#39;https://repo.jamovi.org&#39;, &#39;https://cran.r-project.org&#39;)) To install jmvScaffold R package (check out if you need some dependency) devtools::install_github(&quot;mcfanda/jmvScaffold&quot;) We will see that your module will not need to install jmvScaffold to work, you just need it to program. Thus, when you publish your module, jamovi will not need to install jmvScaffold package. The necessary files to take advantage of the functions and classes provided by jmvScaffold will be part of your module, independently of jmvScaffold package. Thus, no change or update for jmvScaffold will affect your code in the future, nor any link to the package will bind your code to it. 1.3 Create a module A module in jamovi is a R package that works also in jamovi. As such, it needs to have all the characteristics of a R package, plus the additional information and coding required to interface the R package to jamovi. Thus, to obtain a working module we need to make steps both for the R package and for the jamovi interface. We now create a new module, named COOLj. At the end of this material, the COOLj module will look like this. For simplicity, we aim at producing a module that does a linear regression and some other simple statistics. First, we create its folder (so be sure you are in a parent folder) and the folders structure with jmvtool jmvtools::create(&#39;COOLj&#39;) This should produce, in the COOLj folder, this structure. If you use RStudio, it is a good idea to create a project in the COOLj folder, because working with RStudio projects make our lives much easier. We now need to fill the DESCRIPTION file as for any R package. Here an example Package: COOLj Type: Package Title: Simple example of jmvScaffold Version: 0.0.1 Author: mcfanda Maintainer: Mcfanda &lt;yourself@somewhere.net&gt; Description: This is an example of jmvScaffold License: GPL Encoding: UTF-8 LazyData: true Imports: jmvcore (&gt;= 0.8.5), R6 This describes your package in R. Now we need to define a description for jamovi, filling the file ./jamovi/0000.yaml title: Simple example of jmvScaffold name: COOLj version: 0.0.1 jms: &#39;1.0&#39; authors: - Mcfanda maintainer: mcfanda &lt;yourself@somewhere.net&gt; date: &#39;2023-1-1&#39; type: R description: &gt;- This is an example of jmvScaffold analyses: [] usesNative: true minApp: 1.0.8 We will get back to this file later on. For now, we happy. Finally, we copy the jmvScaffold classes in our module ./R folder with jmvScaffold::copy_files() 1.4 Defining the analysis A module can do several things, but at least it should execute one analysis. By analysis I mean a set of stats that would produce some results, such as t-test, a correlation, a machine learning classification algorithm, a Bayesian supercool test equivalent to the t-test . In this example we want to develop a module that deal with linear models. We start simply, and aim at producing a linear regression. We make it more complex later on. This model will be useless, because jamovi already comes with a nice command for regression, Regression-&gt;Linear Regression, or one can install GAMLj module for regressions and many other linear models. Here we set this aim for demonstrative purposes. 1.5 jamovi analysis We want to call this analysis myRegression. so, we create a file named myRegression in the ./jamovi/ folder. jmvtools::addAnalysis(name=&#39;myRegression&#39;, title=&#39;Regression analysis&#39;) The option name decides the name of the R function that will be produced, and the option title decides how the function will be labelled in the jamovi menu (it can be changed later on if needed). Running the command produces several files. In the ./jamovi/ folder we have In them, the jamovi input and output features are defined. In *.a.yaml file the input options are defined, see API here jamovi hub: Analysis. In *.u.yaml file the input layout is of the user interface is defined, see API here jamovi hub: GUI In *.r.yaml file the output results tables are defined, see API here jamovi hub: Results We should fill them all. "],["interface.html", "Chapter 2 Interface 2.1 Options (.a.yaml) 2.2 Layout (.u.yaml) 2.3 Compiling the jamovi module", " Chapter 2 Interface Every jamovi command has a GUI which allow users to set up the analysis and toggle options. All active items in the input GUI are called Options. In the Descriptive analysis, the content of Variables field, Split by field, the toggle option Frequency Tables etc. are all option that we should define. 2.1 Options (.a.yaml) Every control the user sees in the input panel of our analysis must be defined in the *.a.yaml file. An example is this, generated by the jamovi compiler default settings: File: jamovi/myregression.a.yaml (Online version) name: myRegression title: Regression analysis menuGroup: COOLj version: &#39;1.0.0&#39; jas: &#39;1.2&#39; options: - name: data type: Data - name: dep title: Dependent Variable type: Variable - name: group title: Grouping Variable type: Variable - name: alt title: Alternative hypothesis type: List options: - title: Not equal name: notequal - title: One greater name: onegreater - title: Two greater name: twogreater default: notequal Each option should have a name and a type. Depending to the type, other properties can be defined. For our purposes, we need a Variable type to input the dependent variable and a Variables type to input independent variables, plus the Data type that will pass the spreadsheet data to the R package. File: jamovi/myregression.a.yaml (Online version) --- name: myRegression title: Regression analysis menuGroup: COOLj version: &#39;0.0.1&#39; jas: &#39;1.2&#39; options: - name: data type: Data - name: dep title: Dependent Variable type: Variable permitted: - numeric - name: covs title: Covariates type: Variables suggested: - continuous - ordinal permitted: - numeric --- First, notice the menuGroup property. That says in which menu the analysis will appear in jamovi. Because the COOLj menu does not exist, the compiler will create one. Later we see how to put your module under pre-existing menus. Now, the dep option will contain the dependent variable, and the property permitted allows the user to input only numerical variables (see appendix A) for more details about variables types in jamovi). The covs option will contain the numeric independent variables, and the GUI will signal with little icons that the field expects continuous or ordinal variable, ruled by the property suggested. The complete list of options and their properties can be found at the jamovi hub 2.2 Layout (.u.yaml) Next, we need to decide how to lay out the options in the GUI. The layout of the GUI is made of a series of LayoutBox, empty containers that host the controls (the options) as their children. Our options are all numeric, so require an text input control named TextBox. The layout is basically an HTML page, so one can think of a LayoutBox as a &lt;div&gt;, containing all the controls &lt;input type=\"text\"&gt;,&lt;input type=\"checkbox\"&gt; etc. For now, we set it like this: File: jamovi/myregression.u.yaml (Online version) title: Regression analysis name: myRegression jus: &#39;3.0&#39; stage: 0 compilerMode: tame children: - type: LayoutBox margin: large children: - type: TextBox name: es format: number - type: TextBox name: alpha format: number - type: TextBox name: power format: number Notice that we set compiler: to tame, because it tells the jamovi compiler not to override our layout. 2.3 Compiling the jamovi module At this point we compile out module and see what happens. jmvtools::install() If everything went as expected, you should see the COOLj module in jamovi. You do not need to restart jamovi, the compiler would restart the internal engine automatically and you should see the new module. Now we have a scaffold to start programming the stats, so we can now use jmvScaffold. "],["chapter3.html", "Chapter 3 Results 3.1 Preparing the results 3.2 Defining the result tables (.r.yaml) 3.3 R code for jamovi 3.4 Initialize a table 3.5 Populating a table 3.6 Passing data to SmartTables 3.7 Automatic filling of tables. 3.8 R6 classes to run complex modules", " Chapter 3 Results 3.1 Preparing the results Results in jamovi are organized in tables (and some other widget types). Tables are R6 classes with many different properties and options, allowing the programmer to fine-tune the look and feel of the results in details. If you need actions not performed by SmartTable class, you can always twickle the jamovi tables as described in jamovi hub. jmvScaffold provides a R6 class, named SmartTables, which works as an interface between the programmer and the jamovi results API. With that, you can do a lot of things without touching the jamovi results class. Before that, however, we need to declare our tables in the .r.yaml file. In our little project, we need at least one table for the regression results. It is a good idea, I suggest, to see how the R table would look like. In R, we obtain the results of a linear regression with lm() command from stats:: package, so we basically need to run this # data will arrive from jamovi, here we fake one dataset data &lt;- data.frame(y=rnorm(50),x=rnorm(50)) model &lt;- stats::lm(y~x,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -0.1468077 0.1786314 -0.8218474 0.4152275 ## x 0.2100804 0.1754251 1.1975506 0.2369725 Because we do not want spaces in the table heads, we can rename the table names and transform the table into a data.frame. # data will arrive from jamovi, here we fake one dataset coeffs &lt;- as.data.frame(coeffs) names(coeffs)&lt;-c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs ## coef se t p ## (Intercept) -0.1468077 0.1786314 -0.8218474 0.4152275 ## x 0.2100804 0.1754251 1.1975506 0.2369725 now that we know how our table will look like we should get into the R programming. As a side note, I would suggest to always use R commands prefixed with their package name, such as stats::lm rather than lm. This is required if you want to publish your R module in CRAN, and it makes your code much more readable. It is like calling functions with their name and surname, and we want to be polite with our functions. 3.2 Defining the result tables (.r.yaml) All results tables (and other widgets) are defined in the .r.yaml. Here we need a table that will represent the R table we have seen before. So we need the following code. File: jamovi/myregression.a.yaml (Online version) --- name: myRegression title: Regression analysis jrs: &#39;1.1&#39; items: - name: coefficients title: Parameter Estimates (Coefficients) type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: coef title: &quot;Estimate&quot; type: number - name: se title: SE type: number - name: t title: &quot;t&quot; type: number format: zto - name: p title: &quot;p&quot; type: number format: zto,pvalue --- So, a widget of type Table, with columns defined by a name, a title and a format. Details of all widgets definitions can be found in the jamovi hub Compiling the module (2.3) after defining the table in the .r.yaml file produces the table in the output (still empty) 3.3 R code for jamovi When we compiled our module, jamovi compiler produced two R files and put them in the ./R folder. The .h.R file can be ignored, the jamovi compiler produces it every time we install the module. The important file is the .b.R file, where all the action takes place. The .b.R file contains a R6 class named [analysisname]Class, in our case myRegressionClass. The class contains (at least) two private functions, the .init() function and the .run() function. Those are the functions that we need to customize. Before we dive into it, let’s spend two words about how jamovi process works. When the user opens the analysis, or whenever the GUI is updated, jamovi runs your R module in the .b.R file. It calls the .init() function first and then the .run() function. Actually, the .init() function can be absent, but my suggestion is to define it for all analyses, because in the .init() function the tables are formated and prepared to be filled. The .init() function gives you the opportunity to give your output a nice and professional look. Tables are populated in the .run() function. A working .b.R file, that does not do anything, is the following: File: R/myregression.b.R (Online version) myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .init = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) }, .run = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) } ) ) Here is where jmvScaffold comes handy. First, we want to be sure to have installed the jmvScaffold classes. To do that, in R we simply run this code (recall we did it in 1.3 installing the jmvScaffold R package) File: an R file jmvScaffold::copy_files() which copies in the present module ./R folder the necessary files. 3.4 Initialize a table Table objects are passed to the R package with the property self$results. This property is a named list, so we can refer to our table as self$table$coefficients. In the .init() function, we should create a SmartTable object initialized with the table it is going to handle. We simply write this code. File: R/myregression.b.R (Online version) myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .regtab=NULL, .init = function() { private$.regtab&lt;-SmartTable$new(self$results$coefficients) private$.regtab$initTable() }, .run = function() { # `self$data` contains the data # `self$options` contains the options # `self$results` contains the results object (to populate) } ) ) which defines a valilla SmartTable, it initializes it and saves it in a private variable .regtab for later use. At the moment, the initialization does not do anything, but creating the SmartTable object. The jamovi table associated with it has all the properties defined in the r.yaml file, but nothing more. 3.5 Populating a table We can now populate the coefficients jamovi table by interacting with the SmartTable object in the .run() function. First, we need to gather the user choices made in jamovi GUI by collecting the options we defined in the .a.yalm file. All options are available in R as a named list named self$options. So we can get them to define our regression models. We should get the option dep to know which is our dependent variable, then we call the option covs. In the .run() function, we can write. File: R/myregression.b.R (Online version) #...# .run = function() { dep &lt;- self$options$dep covs &lt;- self$options$covs } #...# dep is a string containing the variable name, whereas covs is a list, so we need to manipulated it to make it a formula to pass it to lm(). This can be done easely with jmvcore R package, which provides very useful functions to handle the GUI input in R (see jmvcore Package for details). Here we use the function jmvcore::composeFormula(dep,covs), which transforms a list of terms into a R formula. File: R/myregression.b.R (Online version) #...# .run = function() { dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) } #...# Notice the function is.something(). It is provided by jmvScaffold and it is useful to evaluate options, because options can be of very different classes, and we just want to know if they are set or not. is.something does that. A this point, we should compute the regression and build a R table to pass to our SmartTable object defined before. File: R/myregression.b.R (Online version) myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .regtab=NULL, .init = function() { private$.regtab&lt;-SmartTable$new(self$results$coefficients) private$.regtab$initTable() }, .run = function() { data &lt;- self$data dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) model &lt;- stats::lm(formula,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) private$.regtab$runSource &lt;- coeffs private$.regtab$runTable() } ) ) (I use .foo notation for R variables that are named as primitives in R, but I guess this is not a good practice) What matters here is that we have passed our result table coeffs to the SmartTable with the command private$.regtab$runSource &lt;- coeffs and we have told the table to update with the command private$.regtab$runTable(). We can now install the module in jamovi and check if it works. The rule is simple: every column in the jamovi table is populated with the data in the column with the same name in the R table. It does work! However, the Variable column is empty. We want to fill it with the names of the covariates. So we simply add the code necessary to add a column to our R data.frame. File: R/myregression.b.R (Online version) #...# .run = function() { data &lt;- self$data dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() formula &lt;- jmvcore::composeFormula(dep,covs) model &lt;- stats::lm(formula,data=data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) private$.regtab$runSource &lt;- coeffs private$.regtab$runTable() } #...# We have now a decent table with the results. It goes without saying that one can add any number of covariates, and the table will update automatically. 3.6 Passing data to SmartTables The SmartTable object accepts data to populate the jamovi table in several different formats, so one can use different strategies depending on their need. passing a data.frame to $runSource passing a function that returns a data.frame to $runSource passing a list of named lists, where each list represents a row and the names are the name of the columns passing a function that returns a list of named lists initializing the SmartTable with an R6 object (see later on for a detailed explanation) We can try these strategies (but the last) with some simple code, passing some numbers to our coefficients table. File: R/myregression.b.R #...# .run = function() { ## passing a function fun&lt;-function() { var=c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) coef=1:3 se=4:6 t=7:9 p=10:12 return(data.frame(var,coef,se,t,p)) } private$.regtab$runSource &lt;- fun private$.regtab$runTable() } #...# File: R/myregression.b.R #...# .run = function() { ## passing a list of named list alist&lt;-list( list(var=&quot;x&quot;,coef=1,se=4,t=7,p=10), list(var=&quot;y&quot;,coef=2,se=5,t=8,p=11), list(var=&quot;z&quot;,coef=3,se=6,t=9,p=12) ) private$.regtab$runSource &lt;- alist private$.regtab$runTable() } #...# The possibility to pass results to a SmartTable in different ways gives the programmer flexibility to populate tables from different sources. Nonetheless, when the module gets very complex, even this flexibility cannot be enough. When things get complex, the following method may be the best: Associating the table to a R6 class that it is automatically called by the tables themselves. Sound complex but it is not. 3.7 Automatic filling of tables. You can go a long way off without the this section. One can add tables ad define a function or a procedure to fill each table passing the results data to the $runTable function. However, when your module gets more complex, you want to give a structure to the calls that fill the tables, so you can forget about them and focus on the R programming. Here comes the last method jmvScaffold offers to populate the jamovi tables. When a SmartTable is initialized, it can be associated with an R6 class that provides the functions to run the table. When the table is run with the $runTable() function, it calls the R6 and inquires if the class has a function called run_[tablename]. If it is there, it executes the function and the table is filled with the return of the function. Let’s build this R6 new class, and call it Runner. File: R/Runner.R (Online version) Runner &lt;- R6::R6Class( &quot;Runner&quot;, class=TRUE, cloneable=FALSE, inherit = Scaffold, public=list( analysis=NULL, initialize=function(obj) { self$analysis&lt;-obj }, run_coefficients=function() { # this will be automatically called by SmartTable associated with the `coefficients` table formula &lt;- jmvcore::composeFormula(self$analysis$options$dep,self$analysis$options$covs) model &lt;- stats::lm(formula,data=self$analysis$data) .summary &lt;- summary(model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) coeffs } ) # end of public ) # end of class What we are doing is to define a R6 object of class Scaffold (very useful in the future), that is initialized with jmvcore::Analysis R6 analysis object, in our case it will be the myRegressionClass object, that contains all information we need to do the analyses. We need to save it somewhere, so we store it in the self$analysis field. Alternatively, you can put it in the private fields (good practice), we did not do it for keep the code simpler. If you worry about passing a big R6 class (the jamovi myRegressionClass) to another R6 class (Runner), don’t you worry: they are linked by reference, the memory footprint will not increase much (I guess). Now we need to tell the SmartTable that is is associated with this class. In the myRegression.b.R file we write: File: R/myregression.b.R (Online version) myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .runner=NULL, .regtab=NULL, .init = function() { private$.runner&lt;-Runner$new(self) private$.regtab&lt;-SmartTable$new(self$results$coefficients,private$.runner) private$.regtab$initTable() }, .run = function() { data &lt;- self$data dep &lt;- self$options$dep covs &lt;- self$options$covs if (!is.something(dep) | !is.something(covs)) return() private$.regtab$runTable() } ) ) You can see that we simply initialize the SmartTable with a Runner R6 class, and in the .run() function of the .b.R file we execute the $runTable() function, which calls run_coefficients function in the runner. If it does not get anything, it would not populate the jamovi table. If the run_coefficients function returns some data, it fills the table with them. Install the module (2.3) and you get the expected results. Pretty cool, I dare say. Instead, you might think that this strategy looks a bit complicated and not useful. If so, read on. 3.8 R6 classes to run complex modules Consider now this case (but many more cases are coming). You have 2 tables to fill: regression coefficients, and a ANOVA table (think about keep adding tons of tables, the story would not change). You want to estimate the model only once, and then use the estimation object (an lm class in this case) for several different tables. We now do it for two tables. In the .r.yaml file, we add: File: jamovi/myregression.r.yaml (Online version) #...# - name: anova title: ANOVA table type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: test title: &quot;F-test&quot; type: number format: zto - name: df1 title: &quot;df&quot; type: integer - name: df2 title: &quot;dfres&quot; type: intege - name: p title: &quot;p&quot; type: number format: zto,pvalue in the Runner.R R code file we add a function to estimate the model , and we define one function for each table to populate. First, the estimating function. File: R/Runner.R (Online version) #...# ### we are in the public field of the Runner class public=list( analysis=NULL, model=NULL, initialize=function(obj) { self$analysis&lt;-obj }, estimate=function() { formula &lt;- jmvcore::composeFormula(self$analysis$options$dep,self$analysis$options$covs) self$model &lt;- stats::lm(formula,data=self$analysis$data) }, #...# (again, for simplicity I put the model in a public field self$model, but putting it in private$.model is more elegant). As regards filling the tables, we can do this: File: R/Runner.R (Online version) ### we are in the public field of the Runner class #...# run_coefficients=function() { .summary &lt;- summary(self$model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) return(coeffs) }, run_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual .anova$var &lt;- rownames(.anova) return(.anova) } #...# Now we should program in the myRegression.b.R the new table anova. File: R/myregression.b.R (Online version) myRegressionClass &lt;- if (requireNamespace(&#39;jmvcore&#39;, quietly=TRUE)) R6::R6Class( &quot;myRegressionClass&quot;, inherit = myRegressionBase, private = list( .runner=NULL, # this is a list that contains all the SmartTables .tables=list(), .init = function() { if (!is.something(self$options$dep) | !is.something(self$options$covs)) return() # define the runner private$.runner&lt;-Runner$new(self) # set up the coefficients SmartTable atable&lt;-SmartTable$new(self$results$coefficients,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable # set up the anova SmartTable atable&lt;-SmartTable$new(self$results$anova,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable # init all tables lapply(private$.tables,function(x) x$initTable()) }, .run = function() { if (!is.something(self$options$dep) | !is.something(self$options$covs)) return() # estimate the model private$.runner$estimate() # execute all SmartTable run functions lapply(private$.tables,function(x) x$runTable()) } ) ) From now on, you can simply add results table by defining a table in the .r.yaml file, define a function named run_[tablename] in the Runner.R file, and add the SmartTable to the private$.tables list. Pay attention to the fact that in the .init() function we define our smart object and then add them to a list. At the end, we run the $initTable() function for all objects in the list. The same we do in the .run() function executing the $runTable() function of each object. Later on, when we add additional table, the last command (the lappy(..) command) should always appear after any definition of tables. Let’s do that with a new table, named effectSizes that would output some effect size indices (which will customize later on). First, the .r.yaml. File: jamovi/myregression.r.yaml (Online version) - name: effects title: Effect Size Indices type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: index title: &quot;Index&quot; type: text - name: value title: &quot;Value&quot; type: number format: zto This means we set up a jamovi table named effects with three columns, var, index and value. To fill it, we add in the Runner class a run_effects() function. There, we use the functions in R package to compute the indices, so we need to add it in our DESCRIPTION file as an Imports (not shown here). File: R/Runner.b.R (Online version) #...# run_effects=function() { eps &lt;- effectsize::epsilon_squared(self$model) eps_df &lt;- data.frame(var=eps$Parameter,index=&quot;pEpsilon^2&quot;,value=eps$Epsilon2) eta &lt;- effectsize::eta_squared(self$model) eta_df &lt;- data.frame(var=eta$Parameter,index=&quot;pEta^2&quot;,value=eta$Eta2) omega &lt;- effectsize::omega_squared(self$model) omega_df &lt;- data.frame(var=eta$Parameter,index=&quot;pOmega^2&quot;,value=omega$Omega2) tab &lt;- rbind(eps_df,eta_df,omega_df) return(tab) } #...# Now, we define the table as a SmartTable in the .b.R file and add it to the list of SmartTable objects we defined before. File: R/myregression.b.R (Online version) ## in the `.init()` function # set up the effects SmartTable atable&lt;-SmartTable$new(self$results$effects,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable After installing the module, we should get the results as follows: Aesthetically, the table can improved, but the general idea of setting and populating tables should be now clear. "],["advanced-results-objects.html", "Chapter 4 Advanced Results Objects 4.1 Introduction 4.2 Groups (jmvcore::Group) 4.3 Arrays of tables (jmvcore::Array) 4.4 Other Results objects", " Chapter 4 Advanced Results Objects 4.1 Introduction So far we defined jmvcore::Table objects. Tables, however, are not the only jmvcore::Results object available to the module developer. The results will usually go into tables, but the result tables can be organized in a more rational way, or be created programmatically depending on the module needs. Here are a few useful objects. 4.2 Groups (jmvcore::Group) A useful object is the jmvcore::Group. Groups allow structuring the result tables sections. Assume, for instance, we want to put our coefficients and anova tables in a Main Results section of the output, and our effects table under Additional Output, to be filled later on with other tables. We should change the r.yaml file introducing the Group object: File: jamovi/myregression.a.yaml (Online version) --- name: myRegression title: Regression analysis jrs: &#39;1.1&#39; items: - name: main type: Group title: Main Results items: - name: coefficients title: Parameter Estimates (Coefficients) type: Table columns: - name: var title: &quot;Variable&quot; type: text ... ## here the remaing of the columns as defined before - name: anova title: ANOVA table type: Table columns: - name: var title: &quot;Variable&quot; type: text ... ## here the remaing of the columns as defined before - name: additional type: Group title: Additional Results items: - name: effects title: Effect Size Indices type: Table columns: - name: var title: &quot;Variable&quot; type: text ... ## here the remaing of the columns as defined before Notice that the definition of the tables has not changed, they are just organized under a Group with property title and items. The logic of interfacing R code with the tables via a SmartTable object in file .b.R does not change as well, the only difference is that we should change the name of the table. In the self$results list, tables are now referred to as self$results$groupname$tablename. File: R/myregression.b.R (Online version) ## same code as before here ... .init = function() { if (!is.something(self$options$dep) | !is.something(self$options$covs)) return() # define the runner private$.runner&lt;-Runner$new(self) # set up the coefficients SmartTable atable&lt;-SmartTable$new(self$results$main$coefficients,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable # set up the anova SmartTable atable&lt;-SmartTable$new(self$results$main$anova,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable atable&lt;-SmartTable$new(self$results$additional$effects,private$.runner) # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable # the remaining code does not change ... Consequently, in the Runner.R file their assocated function should be named run_[groupname]_[tablename], because they [groupname]_[tablename] nickname uniquely indentifies each table. In Runner.R code: File: R/Runner.R (Online version) run_main_coefficients=function() { .summary &lt;- summary(self$model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) return(coeffs) }, run_main_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual .anova$var &lt;- rownames(.anova) return(.anova) }, run_additional_effects=function() { eps &lt;- effectsize::epsilon_squared(self$model) eps_df &lt;- data.frame(var=eps$Parameter,index=&quot;Epsilon^2&quot;,value=eps$Epsilon2) eta &lt;- effectsize::eta_squared(self$model) eta_df &lt;- data.frame(var=eta$Parameter,index=&quot;pEta^2&quot;,value=eta$Eta2) omega &lt;- effectsize::omega_squared(self$model) omega_df &lt;- data.frame(var=eta$Parameter,index=&quot;pOmega^2&quot;,value=omega$Omega2) tab &lt;- rbind(eps_df,eta_df,omega_df) return(tab) }, You should now have your output organized in sections like this: 4.3 Arrays of tables (jmvcore::Array) Arrays of tables are complex objects that allow for a lot of flexibility in setting up results tables. They contain tables like groups do, but the number of tables created in an array is flexible and depends on the input or the results. We can distinguish two typical cases. When the number of tables depends on an option defined in the GUI (in the .a.yaml file), or when the number of tables depends on some calculation done in the R code, so not directly linked to an option. Let’s see the two cases in detail. 4.3.1 Array: known number of tables Assume we want to produce a table for each covariate selected by the user. Say that for each covariate you want a separate table with the mean and standard deviation of the variable. Obviously, we do not know in advance how many independent variables the user will define, but as soon as the user defines them, jamovi can count the independent variables and know how many tables are needed. In our example, we can link the number of tables (items) attached to the Array object to the covs option. This can be done directly in the yaml code in .r.yaml file. File: jamovi/myregression.r.yaml (Online version) #...# - name: means title: Mean and Standard deviation type: Array items: (covs) template: title: Variable - $key type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: mean title: &quot;Mean&quot; type: number - name: sd title: &quot;Sd&quot; type: number Notice the items property. We set it to (covs) to signal jamovi to take the contents of the option covs from the input, and create one table for each item found in covs. Thus, for each covariate selected by the user a Table is created as specified in the template: property. In the following example, I get two tables because I selected two covariates. Notice the individual table title. It is set to the name of a covariate because in the title: property we use the special key $key, which means the name of the item found in items: variable. All this is done automatically by jamovi interpreter, so it is very easy and smooth to define arrays like this. Now we can populated each table within the array. First, we go to the .b.R file and define the array. File: R/myregression.b.R (Online version) ## same code as before here #...# .init = function() { ## same code as before here #...# # set up the means SmartArray obj&lt;-SmartArray$new(self$results$means,private$.runner) # put the SmartArray in the list private$.tables[[length(private$.tables)+1]]&lt;-obj # the remaining code does not change #...# Here we use a different jmvScaffold object, called SmartArray. Its API is equivalent to the one of a SmartTable, but passes all the defined properties to the children tables. In the Runner.R file we should set up a function named run_[arrayname] to fill it. This function should return a list of data.frame, one for each item selected in the option associated with the array. In our example, the function should return a list of data.frame, one for each covariate selected by the users. Obviously, it is the developer responsibility to return a list of length equal to the number of items in the array. File: R/Runner.R (Online version) # ... # run_means=function() { tabs &lt;- lapply(self$analysis$options$covs, function (x) { m &lt;- mean(self$analysis$data[[x]],na.rm=TRUE) s &lt;- sd(self$analysis$data[[x]],na.rm=TRUE) data.frame(var=x,mean=m,sd=s) }) return(tabs) } # ... # Results should now be nice as expected. 4.3.2 Array: Unknown number of tables Recall the results in Assume now, for some silly reason, that we want additional tables with means and standard deviations only for covariates that have a significant effect on the dependent variable. In this case, we do not know how many tables we need until we run the analysis and check the results. jmvScaffold::SmartArray can handle this case smoothly: It produces and fills as many tables as we pass to it with a list of data.frame. Let us see an example. In the r.yaml file, we define a new Array as the one before, but without the items:(covs) property, because we do not know which of the covs variable will require a table. We also put the array under a group, because it looks better in the output page. File: jamovi/myregression.r.yaml (Online version) #...# - name: sig type: Group title: Significant covariates items: - name: means title: &quot;&quot; type: Array template: title: Variable - $key type: Table clearWith: - dep - covs columns: - name: var title: &quot;Variable&quot; type: text - name: mean title: &quot;Mean&quot; type: number - name: sd title: &quot;Sd&quot; type: number In the Runner.R file, we simply need to define a run_sig_means() function to select the covariates that we want to display in the new tables. File: R/Runner.R (Online version) #...# run_sig_means=function() { ## select the covs ## results &lt;- as.data.frame(summary(self$model)$coefficients) results &lt;- results[-1,] whichcovs &lt;- rownames(results[results[,4]&lt;.05,]) ## make the tables tabs &lt;- lapply(whichcovs, function (x) { m &lt;- mean(self$analysis$data[[x]],na.rm=TRUE) s &lt;- sd(self$analysis$data[[x]],na.rm=TRUE) data.frame(var=x,mean=m,sd=s) }) return(tabs) } Finaly, we add the new array to the list of smart objects in the .b.R files. File: R/myregression.b.R (Online version) ## same code as before here #...# .init = function() { ## same code as before here #...# # set up the sig_means SmartArray obj&lt;-SmartArray$new(self$results$sig$means,private$.runner) # put the SmartArray in the list private$.tables[[length(private$.tables)+1]]&lt;-obj # the remaining code does not change #...# and we can check after re-installing that the module is working as intended. Now pay attention to the tables titles. They are now Variable - 1 and Variable - 2 because we do not have any key defined. No problem, we can pass the keys to the SmartArray as an attribute of the data we pass to it. Just add to the run_means() function the line and you have your nice titles. File: R/Runner.R (Online version) # ... # run_sig_means=function() { ## select the covs ## results &lt;- as.data.frame(summary(self$model)$coefficients) results &lt;- results[-1,] whichcovs &lt;- rownames(results[results[,4]&lt;.05,]) ## make the tables tabs &lt;- lapply(whichcovs, function (x) { m &lt;- mean(self$analysis$data[[x]],na.rm=TRUE) s &lt;- sd(self$analysis$data[[x]],na.rm=TRUE) data.frame(var=x,mean=m,sd=s) }) attr(tabs,&quot;keys&quot;)&lt;-whichcovs ## passing the keys to the jamovi table return(tabs) } # ... # 4.4 Other Results objects jamovi offers other results objects, very important to develop modules such as Image for diplaying plots, or Html widget to display text using html. They are not handled by jmvScaffold and can easely be filled by accessing to them directly. Information about these objects can be found in jamovi hub: Results . "],["dynamic-tables-appearance.html", "Chapter 5 Dynamic Tables Appearance 5.1 Introduction 5.2 Showing table on option change 5.3 Showing tables programmatically 5.4 Additional strategies", " Chapter 5 Dynamic Tables Appearance 5.1 Introduction Not every table is useful every time we run the analysis. Sometimes you want to hide a table, sometimes a hidden table should appear. jamovi allows hiding and showing the tables as default and programmatically, jmvScaffold helps make the process a bit smoother. Let’s make our module a bit more complex adding one option in the GUI. It allows the user to show the sig_means array, that we now want hidden by default. In the .a.yalm file, we add this two options. File: jamovi/myregression.a.yaml (Online version) #...# - name: show_means title: &quot;Show Means for Sig.&quot; type: Bool default: false #...# 5.2 Showing table on option change In this example, we want the sig_means array to be shown only when the user selects Show means for Sig. in the GUI. We need to modify the .r.yaml file as follows: File: jamovi/myregression.r.yaml (Online version) #...# - name: sig type: Group title: Significant covariates visible: (show_means) items: - name: means title: &quot;&quot; type: Array visible: (show_means) template: title: Variable - $key type: Table columns: - name: var title: &quot;Variable&quot; type: text - name: mean title: &quot;Mean&quot; type: number - name: sd title: &quot;Sd&quot; type: number #...# Notice the visible: property. This means that the Array will be shown only if show_means is set to TRUE, thus when the user flags it. No other modification of the code is required. Notice, furthermore, that given the way SmartArray and SmartTable are implemented, if the table or the array is not visible, the functions to fill it are not run, so an advantage in performance is gained by not running computation that is not need. If you want a table or array to be visible by default by hidden by choice, just set the default of the associated option as true. 5.3 Showing tables programmatically Sometimes you want your module to show tables only when necessary, and the necessity arises from the results. As an example, assume that you want to show the section Additional Ouput only if there is some significant results (again, silly example but we need a case in studying). With this aim, we do not know in advance if the table will be shown, so we have to make it visible only when the results suggest so. There are different strategies to accomplish that, maybe the easiest one is the following. Define in the r.yaml file the table as not visible by default with visible: false. File: jamovi/myregression.r.yaml (Online version) - name: additional type: Group title: Additional Results items: - name: effects title: Effect Size Indices type: Table visible: false ## here we set the default as not visible columns: - name: var title: &quot;Variable&quot; type: text - name: index title: &quot;Index&quot; type: text - name: value title: &quot;Value&quot; type: number format: zto Then go to the .b.R file, in the init() function, and set the proporties of the table as shown here. File: R/myregression.b.R (Online version) atable &lt;- SmartTable$new(self$results$additional$effects,private$.runner) atable$activateOnData &lt;- TRUE private$.tables[[length(private$.tables)+1]]&lt;-atable The $activateOnData property is crucial here: It tells the SmartTable to check its data source (i.e. runner$run_additional_effects()) and make itself visible only if it receives some data. Now we need to be sure that the run_additional_effects() returns something only if there is a significant result in the coefficients. In the Runner.R file, we change the function in: File: R/Runner.R (Online version) run_additional_effects=function() { ## check the covs ## results &lt;- as.data.frame(summary(self$model)$coefficients) results &lt;- results[-1,] whichcovs &lt;- rownames(results[results[,4]&lt;.05,]) if (length(whichcovs)==0) return(NULL) eps &lt;- effectsize::epsilon_squared(self$model) eps_df &lt;- data.frame(var=eps$Parameter,index=&quot;Epsilon^2&quot;,value=eps$Epsilon2) eta &lt;- effectsize::eta_squared(self$model) eta_df &lt;- data.frame(var=eta$Parameter,index=&quot;pEta^2&quot;,value=eta$Eta2) omega &lt;- effectsize::omega_squared(self$model) omega_df &lt;- data.frame(var=eta$Parameter,index=&quot;pOmega^2&quot;,value=omega$Omega2) tab &lt;- rbind(eps_df,eta_df,omega_df) return(tab) }, If you are using the Big 5 data buddled with jamovi, you can try predicting Neuroticism with Openess, which will not show the table, and then with Agreebleness, which will show the table 5.4 Additional strategies Usually the yaml property visible:(option) or the SmartTable $activateOnData are sufficient for all cases of dynamic table appearance. If, however, the developer needs more flexibility, one can set the visible: property to false, and use $activated property of SmartTable. $activated accept TRUE or FALSE, and it is equivalent to the jamovi function table$setVisible(BOOL). Using $activated, however, will also not run the code required to fill the table when $activated&lt;-FALSE, so you do not need to take precaution again running useless computation. "],["warning-failing-and-debuging.html", "Chapter 6 Warning, Failing and Debuging 6.1 Introduction 6.2 Tables debugging 6.3 Mark landmarks 6.4 Automatic Errors 6.5 Automatic Warnings 6.6 Code-generated Warnings and Messages 6.7 Transient messages", " Chapter 6 Warning, Failing and Debuging 6.1 Introduction Before we dive into more sophisticated topics, such as formatting Tables, we should briefly consider the sad fact that sooner or later our code will fail and we need to debug it. Debugging a module in jamovi may be difficult, because when you see the error in the jamovi output, it is often difficult to understand when the error comes from, especially if your code is complex and you have many different tables. In jamovi, you want to have toggled on developer mode, to see informative errors. However, jmvScaffold offers also some methods and functions to help us out. First, when we copied the files from the jmvScaffold package into the module .R/ function, one file copied was named jScafFunctions.R. The file head contains three constants File: R/jScafFunctions.R (Online version) j_DEBUG &lt;- TRUE j_INFO &lt;- TRUE t_INFO &lt;- TRUE we want to set them all to TRUE. After re-installing and opening jamovi from command line, In linux: prompt:~$ flatpack run org.jamovi.jamovi In windows: # Note: I should buy a windows machine 6.2 Tables debugging we can now see in console all the calls to the tables and the process to fill them. For example: This shows a listing made by the module we are building: The SmartTable coefficients in group main is checked for running. It is then run. The same goes for anova in main and the other tables. The array means is initialized (it says inited) and run, etc. 6.3 Mark landmarks Another useful function is mark(...). Mark simply cat in the console whatever is passed to it, after some formatting. The advantage of cat is that can be turned on and off changing the constant j_DEBUG is jmvScafFunctions.R file. Very similar is the function jinfo(...), which is meant to print in console landmarks and checkpoints. This is turned on and off with the constant j_INFO. The difference between mark() and jinfo() is basically its name. The idea is to use jinfo() to landmark the code (like jinfo(\"Init phase\"), ginfo(\"Run phase\") ) as stable reference, whereas to use mark() when debugging and then remove it from the code. Having different names makes greping mark easy when we clean the code. When the module is ready to get published, one sets j_DEBUG, j_INFO and j_TABLE to false e nothing will be printed in the console. 6.4 Automatic Errors This is useful when something fail so we can see where the problem is. Let’s make our code fail, by making a mistake in the run_main_coefficients function in the Runner.R (see coeff rather than coeffs). File: R/Runner.R run_main_coefficients=function() { .summary &lt;- summary(self$model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeff$var &lt;- rownames(coeffs) ## misspelled name return(coeffs) }, Running the module now produces an error in the corresponding table. Notice that the module did not fail completely, only the table affected by the error was not filled. We now know that there’s something wrong in the function running the table. We can also check the console to gather some more information. From the listing we can see that the error was in run_main_coefficients and the object ‘coeff’ was not found. When errors are more complicated, the console listing gives more information than the jamovi table, but one of the two should be enough to get you going in finding the bug. If the error is outside the tables, such as in the .b.R, you get an error at the beginning of the output. 6.5 Automatic Warnings SmartTables automatically gather warnings from the filling functions and display them as note of the jamovi table. We can try this by producing a warning in the run_main_coefficients function. File: R/Runner.R (Online version) run_main_coefficients=function() { .summary &lt;- summary(self$model) coeffs &lt;- .summary$coefficients coeffs &lt;- as.data.frame(coeffs) names(coeffs) &lt;- c(&quot;coef&quot;,&quot;se&quot;,&quot;t&quot;,&quot;p&quot;) coeffs$var &lt;- rownames(coeffs) warning(&quot;something fishy is going on&quot;) return(coeffs) }, So, you do not have to worry about capturing warnings, they are automatically displayed. If you do not want to show warnings automatically, you can capture them within the function and process them as needed, or simply ignore them. 6.6 Code-generated Warnings and Messages Very often, you want to pass messages to tables from outside their filling function. You may, for instance, add a note saying that there are missing values in the data, and the user should be careful in interpreting the results. Other times, you may have a recap table at the beginning of the output, and you want to send a footnote to it to signal that something happens worth mentioning. As an example, assume that a warning is generated in our runner$Estimate(), which does not communicate directly to any table. To broadcast message from anywhere in your module to any table, we can use a method that our Runner class inherits from the parent class Scaffold. The method is named dispatcher. This method accepts warnings or error and sends them to SmartTable and SmartArray. We just need to use it whereever we need in the Runner object. In the example, we alter the Estimate() function to produce a message: File: R/Runner.R (Online version) #...# estimate=function() { formula &lt;- jmvcore::composeFormula(self$analysis$options$dep,self$analysis$options$covs) self$model &lt;- stats::lm(formula,data=self$analysis$data) self$warning&lt;-list(topic=&quot;main_coefficients&quot;, message=&quot;Something great happened in the estimate function&quot;) }, #...# The $dispatcher$warning accepts a list with two fields: topic is the nickname of the table that should receive the message, message is the message. Running this code, we obtain: You can see that now the table shows two notes: one sent by the filling function with a warning (the fishy message) and one sent by the Estimate() function, from different parts of the code. One can add any number of notes. Finally, you can also send and error from anywhere in the code to a table, using the property error. We exemplifies this by sending a message to main_anova table. File: R/Runner.R estimate=function() { formula &lt;- jmvcore::composeFormula(self$analysis$options$dep,self$analysis$options$covs) self$model &lt;- stats::lm(formula,data=self$analysis$data) self$error&lt;-list(topic=&quot;main_anova&quot;, message=&quot;Something bad happened in the estimate function&quot;) }, If you want to send an error message that would stop completely the execution of the analysis, you can add the field final=TRUE to the list passed to dispatcher$error, such as File: R/Runner.R (Online version) #...# self$error&lt;-list(topic=&quot;main_coefficients&quot;, message=&quot;Something bad happened in the estimate function&quot;, final=TRUE) #...# 6.7 Transient messages The are other cases in which you want your message to disappear after execution. Typical case is when some of your table would require a lot of time to execute, and this is known in advance. For instance, the user may select bootstrap inference rather than standard one, so you want to send a message while the bootstrap is being computed that this may take a while. You can do that by sending a message with the initOnly=TRUE field. File: R/Runner.R #...# self$warning&lt;-list(topic=&quot;main_coefficients&quot;, message=&quot;This may take a while&quot;, initOnly=TRUE) #...# This message will be shown until the table is filled, and disappears afterward. We go back to this later on. "],["formatting-tables.html", "Chapter 7 Formatting Tables 7.1 Introduction 7.2 Initializing the table 7.3 Combining below 7.4 Add spaces between rows 7.5 Indent some row value 7.6 Showing columns when needed 7.7 Showing columns programmatically 7.8 Changing column names programmatically 7.9 Super Titles 7.10 Something else 7.11 Adding columns programmatically", " Chapter 7 Formatting Tables 7.1 Introduction Now we can tune the look of our table. We should, however, do a better job in initializing the tables. So far, we did not do anything in the .init() function but running the $initTab() function. Properly initiating the table makes the whole user experience much smoother and pleasant. To convince yourself about that, consider than our little module is very fast now, because we simply run a regression with a few variables. Ponder that your model may take time to obtain the results, maybe because you need to bootstrap, user has billions of data points, or the user has a huge dataset with hundreds of variables. To appreciate the need for a proper initialization of the tables, let slow down our Estimate() function in the Runner by change it like this, re-install and try changing variables or options in the module GUI, as a user would do (we removed the warnings and errors in this chapter). File: R/Runner.R (Online version) estimate=function() { formula &lt;- jmvcore::composeFormula(self$analysis$options$dep,self$analysis$options$covs) self$model &lt;- stats::lm(formula,data=self$analysis$data) Sys.sleep(3) }, What happens with a slightly slower estimation is that the tables will expand and shrink every time the user changes some option, and the whole results section will flicker in an unpleasant way (try yourself after compiling the module with the last chanches). To avoid that, we can set the dimensions and fill some columns of the tables in the $initTable() function phase. SmartTable can be initiated by passing data in the init() phase, data that are typically the name of the rows, such as variables names, or some other fixed information. SmartTable objects $initTab() function inquires the initSource property (if set) or the runner init_tablename() function to get info to fill the tables in the init phase. You want to pass very fast and simple information, and let the actual data to come in in the .run() phase, when we call the $runTable function. Let’s start with effects table, which does not look very good. First, the variables are alternating in the column Variable, which is not a natural way to read the results. It would be better to have each variable with all its effect sizes and then another variable, and so on. So, first we sort the output by variable in the Runner.R filling function. File: R/Runner.R (Online version) run_effects=function() { eps &lt;- effectsize::epsilon_squared(self$model) eps_df &lt;- data.frame(var=eps$Parameter,index=&quot;Epsilon^2&quot;,value=eps$Epsilon2) eta &lt;- effectsize::eta_squared(self$model) eta_df &lt;- data.frame(var=eta$Parameter,index=&quot;pEta^2&quot;,value=eta$Eta2) omega &lt;- effectsize::omega_squared(self$model) omega_df &lt;- data.frame(var=eta$Parameter,index=&quot;pOmega^2&quot;,value=omega$Omega2) tab &lt;- as.data.frame(rbind(eps_df,eta_df,omega_df)) tab &lt;- tab[order(tab$var),] # we order the results by variable return(tab) } 7.2 Initializing the table At the .init() time, we know what the covariates that will be listed in the table and the labels of the effect sizes we want to show. We can pass this info to the table $initTable by defining in Runner a init_additional_effects() function. Recall that in the .init() phase we have all the options, the data definitions, but no estimation nor the actual data. This is made on purpose to keep the .init() phase light and fast. In the Runner, we write. File: R/Runner.R (Online version) #...# init_additional_effects=function() { covs &lt;- self$analysis$options$covs es &lt;- c(&quot;pEpsilon&quot;,&quot;pEta&quot;,&quot;pOmega&quot;) tab &lt;- as.data.frame(expand.grid(covs,es)) names(tab)&lt;- c(&quot;var&quot;,&quot;index&quot;) tab &lt;- tab[order(tab$var),] return(tab) }, #...# We are passing to the init_[tablename] function a data.frame with the var and the index labels, that we know as soon as the GUI is updated. If you play around with the GUI of your module, you can notice that now the Effects Size Indices gets ready very quickly, with the correct number of rows, and it is finalized with the numerical values when the estimation is done. (remove the Sys.sleep(3) for future usage) Note: one does not need to prepare a init_tablename() function for each table. It should be done for tables that requires some formatting before hand, such as the formatting options discussed below. 7.3 Combining below (ref. SmartTable$CombineBelow) At this point, we can notice that the repetition of the Variable name makes the table a bit heavy (column name is var). We can make it look better by removing the repeated labels and let them print only when a new variable name appears. This can be in the .r.yaml file by adding combineBelow: true property. File: jamovi/myregression.r.yaml (Online version) #...# type: Table visible: true columns: - name: var title: &quot;Variable&quot; type: text combineBelow: true ... #...# The results are more pleasantly looking. 7.4 Add spaces between rows (ref. SmartTable$spaceBy) Another way to make tables more pleasant looking is to add some space between rows that are someway logically separated. In our table Effects Size Indices we can separate a bit the sets of indices between variables. We can use SmartTable property $spacyBy. spaceBy accepts a column name or a vector of indices, indicating where to put the space. When the argument is a column name, or a vector of names, the space is inserted when the column changes value. In practices, we define the SmartTable like this. File: R/myregression.b.R (Online version) #...# atable &lt;- SmartTable$new(self$results$additional$effects,private$.runner) atable$spaceBy &lt;- &quot;var&quot; # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable #...# 7.5 Indent some row value (ref. SmartTable$indent) Another stylistic change we can make to our tables is to indent some rows to improve readability. Indent can be passed to a SmartTable as a vector of rows indices. The values of the first column at the provided indices will be indent. As a quick example, we indent the first row label of the effects table. File: R/myregression.b.R (Online version) #...# atable&lt;-SmartTable$new(self$results$additional$effects,private$.runner) atable$spaceBy &lt;- &quot;var&quot; atable$indent &lt;- 1 # put the SmartTable in the list private$.tables[[length(private$.tables)+1]]&lt;-atable #...# 7.6 Showing columns when needed There are applications in which one or more columns of a table are not always necessary, so you want to show them only when needed. An example would be to show the confidence intervals of our effect size indices only when the user requires them flagging an option. In other situations, you do not know in advanced if the column is needed, because its relevance depends on the obtained results. jamovi allows handling these cases. Linking a column visibility to an option is the easiest way. Lets’ define an option in the .a.yaml file to toggle confidence intervals appearance. File: jamovi/myregression.a.yaml (Online version) - name: show_ci title: ES CI type: Bool default: false and change effects table in the .r.yaml file File: jamovi/myregression.r.yaml (Online version) #...# - name: additional type: Group title: Additional Results items: - name: effects title: Effect Size Indices type: Table visible: true columns: - name: var title: &quot;Variable&quot; type: text combineBelow: true - name: index title: &quot;Index&quot; type: text - name: value title: &quot;Value&quot; type: number format: zto - name: es_ci_lower title: Lower type: number visible: (show_ci) - name: es_ci_upper title: Upper type: number visible: (show_ci) #...# You can see that the two new columns, es_ci_lower and es_ci_upper have their visibility linked to the option show_ci. After compiling, we get the following behavior (you will fill up with data the new columns as usual, not shown here). 7.7 Showing columns programmatically Another case is when a column visibility depends on your results. For example, in certain mixed models, emmeans R package can be used to obtain the estimated marginal means, that are returned with their CI and the degrees of freedom. However, when the number of rows in the data are too many, the DF are set to Inf (because the CI uses the z-test). So we want to hide the degrees of freedom column after Inf values are produced by our code. To try out, we can reproduce this case in our Runner filling function of the table anova like this. We draw a uniform random number, if it is larger than .5 we set the df1 column to Inf. File: R/Runner.R (Online version) #...# run_main_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual test &lt;- runif(1,0,1)&gt;.5 # we simulate unneeded columns not expected apriori if (test) .anova$df1 &lt;- Inf return(.anova) }, #...# If you try installing and play around with the GUI (just toggle one option on and off), every now and then you would see all Inf in the df column. When this happens, we want to hide the column. With this aim, we add the property $hideOn to the definition of the SmartTable in .b.R file. File: R/myregression.b.R (Online version) atable&lt;-SmartTable$new(self$results$main$anova,private$.runner) ## here we hide `df1` when it receives NaN atable$hideOn &lt;- list(df1=Inf) private$.tables[[length(private$.tables)+1]]&lt;-atable The property $hideOn accepts a named list, with format list(columnan=value) where value is the value that, when received in the data, hides the column. Installing the module now and playing around should produce the expected behavior. 7.8 Changing column names programmatically Another case is when mutually alternative columns should be shown programmatically (after the results are produced). A case is when car::Anova() is applied to different linear models: It may produce a F-test or a Chi-square test. Obviously, one can program each case separately (with an S3 method, for instance), or simply change the name of the column reporting the test depending on the results. To exemplify, let assume that you need to change the name of a column programmatically. You only need to attach to the data.frame passed to the table the attribute titles, as a named list of the form list(columnname=\"new title\"). As follows: File: R/Runner.R (Online version) run_main_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual .anova$var &lt;- rownames(.anova) test1 &lt;- runif(1,0,1)&gt;.5 # we simulate unneeded columns not expected apriori if (test1) .anova$df1 &lt;- Inf test2 &lt;- runif(1,0,1)&gt;.5 if (test2) attr(.anova,&quot;titles&quot;)&lt;-list(test=&quot;Chi-squares&quot;) return(.anova) }, If you try out (flag and unflag some option in the GUI), you’ll see that the F-test column appears as Chi-square every now and then. 7.9 Super Titles (ref. SmartTable$superTitle) The effect size table with the confidence intervals does not look fine (ignore that we did not fill the new column, it is not the point now). The Upper and Lower columns would look much better if they had a title over them, showing that they refer to the 95% confidence intervals. We can do that with supertitles. With SmartTable you simply add a supertitle as follows: File: R/myregression.b.R (Online version) atable&lt;-SmartTable$new(self$results$additional$effects,private$.runner) # ... # atable$superTitle &lt;- list(es_ci_lower=&quot;95% confidence interval&quot;,es_ci_upper=&quot;95% confidence interval&quot;) private$.tables[[length(private$.tables)+1]]&lt;-atable The property $superTitle accepts a list of the format list(columnname1=\"super title\",columnname2=\"super title\",...). Here we tell the table to put a super title to the two es_ci_lower and es_ci_upper, as shown here. 7.10 Something else As a final touch, we can remove the ugly string representing the greek letters in table additional_effects. You can pass to a text columns any ascii value or UTF value. We can adjust the init_[tablename]() function to pass those values. File: R/Runner.R (Online version) init_additional_effects=function() { covs &lt;- self$analysis$options$covs es &lt;- c(&#39;\\u03b5&#39;,&#39;\\u03b7&#39;,&#39;\\u03c9&#39;) ## greek UTF for letter es &lt;- paste(es,&#39;\\u00B2&#39;,sep=&quot;&quot;) # UTF for square tab &lt;- as.data.frame(expand.grid(covs,es)) names(tab)&lt;- c(&quot;var&quot;,&quot;index&quot;) tab &lt;- tab[order(tab$var),] return(tab) }, run_additional_effects=function() { eps &lt;- effectsize::epsilon_squared(self$model) eps_df &lt;- data.frame(var=eps$Parameter,value=eps$Epsilon2) eta &lt;- effectsize::eta_squared(self$model) eta_df &lt;- data.frame(var=eta$Parameter,value=eta$Eta2) omega &lt;- effectsize::omega_squared(self$model) omega_df &lt;- data.frame(var=eta$Parameter,value=omega$Omega2) tab &lt;- as.data.frame(rbind(eps_df,eta_df,omega_df)) tab &lt;- tab[order(tab$var),] return(tab) }, Notice that we define the columns var and index in init_additional_effects function, and we no longer pass these columns in the run_additional_effects. The general principle is: formatting in init_tablename, data in run_tablename. 7.11 Adding columns programmatically There are occasions in which one cannot anticipate how many columns a table should have. A typical example is when you need to show a matrix, like a correlation matrix. Let us make an example planning to add a correlation matrix among all the covariates and the dependent variable. First, we create a new table in the .r.yaml file with only one column, the column that will contain the variables names. File: jamovi/myregression.r.yaml (Online version) - name: correlations title: Correlations type: Table visible: true columns: - name: var title: &quot;Variable&quot; type: text Then we add a SmartTable to the .b.R file. File: R/myregression.b.R (Online version) # set up the means SmartTable obj&lt;-SmartTable$new(self$results$correlations,private$.runner) obj$expandOnInit &lt;- TRUE obj$expandFrom &lt;- 2 private$.tables[[length(private$.tables)+1]]&lt;-obj We define the SmartTable as all the other tables, but we set the $expandOnInit property to TRUE and $expandFrom set to 2. These two properties tell the table to expand columnwise adding any column that will be passed in the init_correlations() function in the Runner. The new columns are added from the second column on. By default, they are added on the left of the table. Now we prepare the functions to fill the table in Runner.R File: R/Runner.R (Online version) init_correlations=function() { vars&lt;-c(self$analysis$options$dep,self$analysis$options$covs) tab&lt;-as.data.frame(matrix(&quot;.&quot;,nrow = length(vars),ncol=length(vars))) names(tab) &lt;- vars tab$var &lt;- vars return(tab) } In the init function we pass a data.frame which has K+1 columns where K is the number of covariates and K rows. Notice that we fill the var variable with the names of the covariate and all other values equal to \".\". SmartTable would consider \".\" as an empty value, but as compared with passing NA, will not consider the table filled, and thus will update with the runTable. Now we set the filling function: File: R/Runner.R (Online version) #...# run_correlations=function() { vars&lt;-c(self$analysis$options$dep,self$analysis$options$covs) tab&lt;-as.data.frame(cor(self$analysis$data[,vars])) return(tab) } #...# "],["smart-tables-update.html", "Chapter 8 Smart Tables Update 8.1 The issue 8.2 The Solution 8.3 Bottom line", " Chapter 8 Smart Tables Update 8.1 The issue The COOLj module we are building is pretty fast, so we can update its options and still get a smooth feeling from the output section. Indeed, if we are using the Big 5 data with 4 covariates, we can flag and unflag the Show means for Sig. or ES CI options and get the results very quickly. Imagine now that your module gets quite complex, with tens of tables and options. Likely, some of the table will require some time to update (maybe one uses bootstrap, for instance), and that will slow down the appearance of all other tables. Let’s simulate that by artificially slowing down our (original) anova tables. File: R/Runner.R (Online version) #...# run_main_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual .anova$var &lt;- rownames(.anova) Sys.sleep(3) ## simulate a slow computation return(.anova) }, #...# If you try now, you’ll see that every time the user changes something in the GUI, they have to wait for all tables to be filled. This behavior can be changed. 8.2 The Solution Many tables do not need to be re-run every time an option is changed. Our anova table, for instance, does not need to be re-computed when we ask for the means, by flagging the Show means option. The two tables are independent, so showing one should not affect showing the other. By default, all jamovi tables are initialized and run every time the input GUI changed. We can change this behavior by adding the property clearWith: to the tables in .r.yaml file. In clearWith:, one can specify the options that would update the table. All changes in other options will not update the table. Thus, in our example, we can set .r.yaml file as follows: File: jamov/myregression.r.yaml (Online version) # ... ## - name: anova title: ANOVA table type: Table ## Here is the new property clearWith: - dep - covs columns: - name: var title: &quot;Variable&quot; type: text ## ... ## Then we need to init the table, with some simple information like this: File: R/Runner.R (Online version) #...# init_main_anova=function() { covs &lt;- self$analysis$options$covs terms &lt;- c(&quot;(Intercept)&quot;,covs,&quot;Residuals&quot;) tab &lt;- lapply(terms, function(x) list(var=x)) return(tab) }, # the run function did not change run_main_anova=function() { .anova &lt;- as.data.frame(car::Anova(self$model,type=3)) names(.anova) &lt;- c(&quot;nothing&quot;,&quot;df1&quot;,&quot;test&quot;,&quot;p&quot;) .anova$df2 &lt;- self$model$df.residual .anova$var &lt;- rownames(.anova) Sys.sleep(3) ## simulate a slow computation return(.anova) }, #...# If you now compile the module and flag and the unflag the Show Means for Sig. option, you’ll see that the anova table do not change and the execution becomes much faster. If you chance the dependent variable or some of the covariates, the two tables will update. If you do this process for all the tables, you will see that they update only when needed. The only exception are Unkeyed Arrays of tables (the ones you defined based on the results, such as the sig_means array in the example). They are always refilled, because jamovi cannot know in advanced how many tables you need. 8.3 Bottom line One can program jamovi modules freely with all techniques one wishes. If one wants to take advantege of jamovi flexibility and jmvScaffold helping function, one can follow this guidelines: Define a table in .r.yaml Define a Scaffold runner Associate each table in the .b.R file to a SmartTable or Smart Array Write a init_tablename in the Runner object to initialize the table Write a run_tablename in the Runner object to fill the table Adjust the aestetics of the table in the .b.R file "],["formatting-tables-1.html", "Chapter 9 Formatting Tables", " Chapter 9 Formatting Tables knitr::knit_engines$get(&quot;yaml&quot;) "],["appendixa.html", "A Appendix A", " A Appendix A jamovi classifies data variables in three classes: Nominal : categorical factor, it is passed to the R engine as a factor. Its behavior in jamovi interface depends on the Data Type property. We have Data Type: integer it can be inserted in input field that permit numerical variable and nominal variables Data Type: text it can be inserted in input field that permit nominal variables Data Type: decimal it does not exist. Setting Data Type to decimal makes the variable a continuous type Continuous : numerical variable, it is passed to the R engine as a number. It can be input in the variable field that permit numerical variable. The data type property behaves like this: Data Type: integer it rounds the values to the closer integer Data Type: decimal allows for floating points Data Type: text it does not exist, setting Data Type to text transforms the variable into a nominal variable Ordinal : numerical variable, it is passed to the R engine as a ordered factor. It can be input in the variable field that permit numerical and ordinal variables variable. The data type property behaves like this: Data Type: integer it can be inserted in input field that permit numerical variable and nominal variables Data Type: text it can be inserted in input field that permit nominal variables Data Type: decimal it does not exist. Setting Data Type to decimal makes the variable a continuous type ID : something cool which I do not know about. "]]
